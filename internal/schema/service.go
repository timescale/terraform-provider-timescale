package schema

import (
	"context"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	ds_schema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/timescale/terraform-provider-timescale/internal/client"
	multiplyvalidator "github.com/timescale/terraform-provider-timescale/internal/utils"
)

const (
	DefaultMilliCPU = 500
	DefaultMemoryGB = 2

	DefaultEnableHAReplica = false
)

var (
	memorySizes   = []int64{2, 4, 8, 16, 32, 64, 128}
	milliCPUSizes = []int64{500, 1000, 2000, 4000, 8000, 16000, 32000}

	ServiceAttrType = types.ObjectType{
		AttrTypes: map[string]attr.Type{
			"id":                types.StringType,
			"name":              types.StringType,
			"milli_cpu":         types.Int64Type,
			"storage_gb":        types.Int64Type,
			"memory_gb":         types.Int64Type,
			"password":          types.StringType,
			"hostname":          types.StringType,
			"port":              types.Int64Type,
			"username":          types.StringType,
			"region_code":       types.StringType,
			"enable_ha_replica": types.BoolType,
			"vpc_id":            types.Int64Type,
			"created":           types.StringType,
		},
	}
)

type ServiceModel struct {
	ID              types.String   `tfsdk:"id"`
	Name            types.String   `tfsdk:"name"`
	Timeouts        timeouts.Value `tfsdk:"timeouts"`
	MilliCPU        types.Int64    `tfsdk:"milli_cpu"`
	StorageGB       types.Int64    `tfsdk:"storage_gb"`
	MemoryGB        types.Int64    `tfsdk:"memory_gb"`
	Password        types.String   `tfsdk:"password"`
	Hostname        types.String   `tfsdk:"hostname"`
	Port            types.Int64    `tfsdk:"port"`
	Username        types.String   `tfsdk:"username"`
	RegionCode      types.String   `tfsdk:"region_code"`
	EnableHAReplica types.Bool     `tfsdk:"enable_ha_replica"`
	VpcId           types.Int64    `tfsdk:"vpc_id"`
	Created         types.String   `tfsdk:"created"`
}

func Service() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"id": schema.StringAttribute{
			MarkdownDescription: "Service ID is the unique identifier for this service.",
			Description:         "service id",
			Computed:            true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.UseStateForUnknown(),
			},
		},
		"name": schema.StringAttribute{
			MarkdownDescription: "Service Name is the configurable name assigned to this resource. If none is provided, a default will be generated by the provider.",
			Description:         "service name",
			Optional:            true,
			// If the name attribute is absent, the provider will generate a default.
			Computed: true,
		},
		"timeouts": timeouts.Attributes(context.Background(), timeouts.Opts{
			Create: true,
		}),
		"milli_cpu": schema.Int64Attribute{
			MarkdownDescription: "Milli CPU",
			Description:         "Milli CPU",
			Optional:            true,
			Computed:            true,
			Default:             int64default.StaticInt64(DefaultMilliCPU),
			Validators: []validator.Int64{
				int64validator.OneOf(milliCPUSizes...),
				multiplyvalidator.EqualToMultipleOf(250, path.Expressions{
					path.MatchRoot("memory_gb"),
				}...),
			},
		},
		"storage_gb": schema.Int64Attribute{
			MarkdownDescription: "Deprecated: Storage GB",
			Description:         "Deprecated: Storage GB",
			Optional:            true,
			DeprecationMessage:  "This field is ignored. With the new usage-based storage Timescale automatically allocates the disk space needed by your service and you only pay for the disk space you use.",
		},
		"memory_gb": schema.Int64Attribute{
			MarkdownDescription: "Memory GB",
			Description:         "Memory GB",
			Optional:            true,
			Computed:            true,
			Default:             int64default.StaticInt64(DefaultMemoryGB),
			Validators:          []validator.Int64{int64validator.OneOf(memorySizes...)},
		},
		"password": schema.StringAttribute{
			Description:         "The Postgres password for this service. The password is provided once during service creation",
			MarkdownDescription: "The Postgres password for this service. The password is provided once during service creation",
			Computed:            true,
			Sensitive:           true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.UseStateForUnknown(),
			},
		},
		"hostname": schema.StringAttribute{
			Description:         "The hostname for this service",
			MarkdownDescription: "The hostname for this service",
			Computed:            true,
		},
		"port": schema.Int64Attribute{
			Description:         "The port for this service",
			MarkdownDescription: "The port for this service",
			Computed:            true,
		},
		"username": schema.StringAttribute{
			Description:         "The Postgres user for this service",
			MarkdownDescription: "The Postgres user for this service",
			Computed:            true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.UseStateForUnknown(),
			},
		},
		"region_code": schema.StringAttribute{
			Description:         `The region for this service`,
			MarkdownDescription: "The region for this service.",
			Optional:            true,
			Computed:            true,
			PlanModifiers: []planmodifier.String{
				stringplanmodifier.UseStateForUnknown(),
			},
		},
		"enable_ha_replica": schema.BoolAttribute{
			MarkdownDescription: "Enable HA Replica",
			Description:         "Enable HA Replica",
			Optional:            true,
			Computed:            true,
			Default:             booldefault.StaticBool(DefaultEnableHAReplica),
		},
		"vpc_id": schema.Int64Attribute{
			Description:         `The VpcID this service is tied to.`,
			MarkdownDescription: `The VpcID this service is tied to.`,
			Optional:            true,
			PlanModifiers: []planmodifier.Int64{
				int64planmodifier.UseStateForUnknown(),
			},
		},
		"created": schema.StringAttribute{
			MarkdownDescription: "Created is the time this service was created.",
			Description:         "Created is the time this service was created.",
			Computed:            true,
		},
	}
}

func ServiceDS() map[string]ds_schema.Attribute {
	return map[string]ds_schema.Attribute{
		"id": ds_schema.StringAttribute{
			MarkdownDescription: "Service ID is the unique identifier for this service.",
			Description:         "service id",
			Computed:            true,
		},
		"name": ds_schema.StringAttribute{
			MarkdownDescription: "Service Name is the configurable name assigned to this resource. If none is provided, a default will be generated by the provider.",
			Description:         "service name",
			Computed:            true,
		},
		"timeouts": timeouts.Attributes(context.Background(), timeouts.Opts{
			Create: true,
		}),
		"milli_cpu": ds_schema.Int64Attribute{
			MarkdownDescription: "Milli CPU",
			Description:         "Milli CPU",
			Computed:            true,
		},
		"memory_gb": ds_schema.Int64Attribute{
			MarkdownDescription: "Memory GB",
			Description:         "Memory GB",
			Computed:            true,
		},
		"hostname": ds_schema.StringAttribute{
			Description:         "The hostname for this service",
			MarkdownDescription: "The hostname for this service",
			Computed:            true,
		},
		"port": ds_schema.Int64Attribute{
			Description:         "The port for this service",
			MarkdownDescription: "The port for this service",
			Computed:            true,
		},
		"username": ds_schema.StringAttribute{
			Description:         "The Postgres user for this service",
			MarkdownDescription: "The Postgres user for this service",
			Computed:            true,
		},
		"region_code": ds_schema.StringAttribute{
			Description:         `The region for this service`,
			MarkdownDescription: "The region for this service.",
			Computed:            true,
		},
		"enable_ha_replica": ds_schema.BoolAttribute{
			MarkdownDescription: "Enable HA Replica",
			Description:         "Enable HA Replica",
			Computed:            true,
		},
		"vpc_id": ds_schema.Int64Attribute{
			Description:         `The VpcID this service is tied to.`,
			MarkdownDescription: `The VpcID this service is tied to.`,
			Optional:            true,
		},
		"created": ds_schema.StringAttribute{
			MarkdownDescription: "Created is the time this service was created.",
			Description:         "Created is the time this service was created.",
			Computed:            true,
		},
	}
}

func NewService(ctx context.Context, s *client.Service, diags *diag.Diagnostics, state *ServiceModel) attr.Value {
	res := ServiceModel{
		ID:              types.StringValue(s.ID),
		Name:            types.StringValue(s.Name),
		RegionCode:      types.StringValue(s.RegionCode),
		Hostname:        types.StringValue(s.ServiceSpec.Hostname),
		Username:        types.StringValue(s.ServiceSpec.Username),
		Port:            types.Int64Value(s.ServiceSpec.Port),
		Created:         types.StringValue(s.Created),
		MilliCPU:        types.Int64Value(s.Resources[0].Spec.MilliCPU),
		MemoryGB:        types.Int64Value(s.Resources[0].Spec.MemoryGB),
		EnableHAReplica: types.BoolValue(s.ReplicaStatus != ""),
	}
	if state != nil {
		res.Password = state.Password
		res.Timeouts = state.Timeouts
	}
	if s.VpcEndpoint != nil {
		if vpcId, err := strconv.ParseInt(s.VpcEndpoint.VpcId, 10, 64); err != nil {
			diags.AddError("Parse Error", "could not parse vpcID")
		} else {
			res.VpcId = types.Int64Value(vpcId)
		}
		res.Hostname = types.StringValue(s.VpcEndpoint.Host)
		res.Port = types.Int64Value(s.VpcEndpoint.Port)
	}
	var value attr.Value
	diags.Append(tfsdk.ValueFrom(
		ctx,
		res,
		ServiceAttrType,
		&value,
	)...)
	return value
}
